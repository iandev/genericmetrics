package main

import (
	"flag"
	"html/template"
	"log"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/iandev/genericmetrics/metrics"
)

var prometheusTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file was generated at
// {{ .Timestamp }}
package metrics

import "github.com/prometheus/client_golang/prometheus"

{{- range .Funcs }}
{{if eq (index .Methods "inc") true}}
// Inc calls the prometheus Inc function using {{ .MetricName }} for tags
func (m {{ .MetricName }}) Inc() {
	labels := []string{
	{{- range .MetricTags }}
		"{{ printf "%s" .}}",
	{{- end }}
	}
	opts := prometheus.CounterOpts{Name: "{{ .MetricName }}", Help: "{{ index .Provider "help" }}"}
	prometheus.NewCounterVec(opts, labels).WithLabelValues(
	{{- range .MetricTags }}
		m.{{ printf "%s" .}},
	{{- end }}
	).Inc()
}
{{end}}

{{if eq (index .Methods "desc") true}}
// Desc returns the prometheus Counter Desc
func (m {{ .MetricName }}) Desc() *prometheus.Desc {
	labels := []string{
	{{- range .MetricTags }}
		"{{ printf "%s" .}}",
	{{- end }}
	}
	opts := prometheus.CounterOpts{Name: "{{ .MetricName }}", Help: "{{ index .Provider "help" }}"}
	return prometheus.NewCounterVec(opts, labels).WithLabelValues(
	{{- range .MetricTags }}
		m.{{ printf "%s" .}},
	{{- end }}
	).Desc()
}
{{end}}
{{- end }}
`

var templates = map[string]*template.Template{
	"prometheus": template.Must(template.New("").Parse(prometheusTemplate)),
}

type MetricFuncs struct {
	MetricName string
	MetricTags []string
	Provider   map[string]string
	Methods    map[string]bool
}

func main() {
	var template *template.Template
	var ok bool

	var p = flag.String("p", "prometheus", "help message for flagname")
	var output = flag.String("o", "", "help message for flagname")
	flag.Parse()
	provider := *p

	if template, ok = templates[provider]; !ok {
		log.Fatal("not a valid metrics template")
	}

	funcs := []MetricFuncs{}

	m := reflect.TypeOf(metrics.MetricTypes{})
	for i := 0; i < m.NumField(); i++ {
		varType := m.Field(i).Type
		metricName := varType.Name()

		labels := make([]string, varType.NumField())

		for j := 0; j < varType.NumField(); j++ {
			labels[j] = varType.Field(j).Name
		}

		fun := MetricFuncs{
			MetricName: metricName,
			MetricTags: labels,
			Provider:   map[string]string{},
			Methods:    map[string]bool{},
		}

		methods := strings.Split(m.Field(i).Tag.Get("methods"), ",")
		for _, method := range methods {
			fun.Methods[strings.TrimSpace(method)] = true
		}

		tag := m.Field(i).Tag.Get(provider)
		tagattrs := strings.Split(tag, ",")
		for _, tagattr := range tagattrs {
			t := strings.Split(tagattr, "=")
			if len(t) == 2 {
				fun.Provider[strings.TrimSpace(t[0])] = strings.TrimSpace(t[1])
			}
		}

		funcs = append(funcs, fun)
	}

	out, err := os.Create(*output)
	if err != nil {
		log.Fatal("Cannot create funcs.go file")
	}
	defer out.Close()

	template.Execute(out, struct {
		Timestamp time.Time
		Funcs     []MetricFuncs
	}{
		Timestamp: time.Now(),
		Funcs:     funcs,
	})
}
